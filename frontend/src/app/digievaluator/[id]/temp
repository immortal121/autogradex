"use client";
import React, { useState, useEffect, useContext, useCallback, useRef } from "react";

import { useParams } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import {
  AppBar,
  Toolbar,
  Box,
  IconButton,
  Button,
  FormControl,
  Select,
  InputLabel,
  MenuItem,
  Typography,
  Tooltip,
} from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import ArrowBack from "@mui/icons-material/ArrowBack";
import CloseIcon from "@mui/icons-material/Close";
import UndoIcon from "@mui/icons-material/Undo";
import RedoIcon from "@mui/icons-material/Redo";
import DoneIcon from '@mui/icons-material/Done';
import Logo from "../../../../public/autograde.jpeg";
import ClearIcon from '@mui/icons-material/Clear';


import { MainContext } from "@/context/context";


export default function Home() {


  const { id } = useParams();

  const [lmenu, setLmenu] = useState(false); // Controls left bar visibility on small screens
  const [rmenu, setRmenu] = useState(false); // Placeholder for right bar toggle
  const [student, setStudent] = useState([]);
  const [page, setPage] = useState('');
  const [selectedStudent, setSelectedStudent] = useState(null);
  const [marks, setMarks] = useState([]); // Store marks for the student's page
  const [scores, setScores] = useState({}); // Store scores for the student's assignment
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(1);
  const { assignments, getFilteredAssignment, updateAssignmentStudents, UpdateScoresByDigitalEvaluator } = useContext(MainContext);
  const [selectedQuestion, setSelectedQuestion] = useState(null);
  const [selectedLabel, setSelectedLabel] = useState();
  const [selectedSection, setSelectedSection] = useState(null);
  const [hoveredMark, setHoveredMark] = useState();
  const [globalState, setGlobalState] = useState({});

  const imageRef = useRef();

  const marksLabels = [
    0.5,
    ...Array.from({ length: 11 }, (_, i) => i), // "0" to "10"
  ];

  const tools = ["Undo", "Redo", "Tick", "Wrong"];

  // const [data,setData] = useState([{}]);

  const [update, setUpdate] = useState(false);
  const [comments, setComments] = useState({});
  const [overallComment, setOverallComment] = useState("");



  // Fetch assignment details and students on page load
  useEffect(() => {
    const fetchData = async () => {
      const assignmentData = await getFilteredAssignment(id);
      setStudent(assignmentData.students || []); // Store students data
    };
    fetchData();
  }, [id, update]);

  useEffect(() => {
    const loadStudentData = async () => {
      if (!student) return;

      // Fetch the student's existing data from the backend
      const studentData = student;

      if (studentData) {
        console.log(studentData);
        const existingMarks = studentData.marksBreakdown.reduce((acc, page) => {
          console.log(acc);
          console.log(page);
          acc[page.page] = page.labels.map(label => ({
            sectionName: label.sectionName,
            questionNo: label.questionNo,
            label: label.marksGiven,
            x: label.x,
            y: label.y,
            comment: label.comment,
          }));
          return acc;
        }, {});

        const existingComments = studentData.marksBreakdown.reduce((acc, page) => {
          page.labels.forEach(label => {
            
            acc[`${label.sectionName}-${label.questionNo}`] = label.comment || '';
          });
          return acc;
        }, {});

        setMarks(existingMarks);

        setScores(
          studentData.marksBreakdown.reduce((acc, page) => {
            page.labels.forEach(label => {
              const questionKey = `${label.sectionName}-${label.questionNo}`;

              acc[questionKey] = label.marksGiven || 0; // Default to 0 if undefined
            });
            return acc;
          }, {})
        );

        setComments(existingComments);
        setOverallComment(studentData.comments || '');
        setGlobalState(prevState => ({
          ...prevState,
          [student.id]: {
            marks: existingMarks,
            comments: existingComments,
            overallComment: studentData.comments || '',
          },
        }));
      }
    };

    loadStudentData();
  }, [student]);


  // console.log(scores);
  const handleOverallCommentChange = (comment) => {
    setOverallComment(comment);

    // Update global state with the overall comment
    setGlobalState((prevState) => ({
      ...prevState,
      [selectedStudent.id]: {
        ...prevState[selectedStudent.id],
        overallComment: comment,
      },
    }));
  };





  // Reset data when switching students
  const resetStudentData = () => {
    setGlobalState({});
    setMarks([]);
    setScores({});
    setHistory([]);
    setHistoryIndex(-1);
  };

  const handleCommentChange = (question, comment) => {
    const questionKey = `${question.sectionName}-${question.questionNo}`;

    setComments(prevComments => ({
      ...prevComments,
      [questionKey]: comment,
    }));

    saveToGlobalState(selectedStudent.id, page, marks, {
      ...comments,
      [questionKey]: comment,
    });
  };


  const handleScoreChange = (section, question, value) => {
    const maxScore = question.marks;

    if (parseFloat(value) > maxScore) {
      alert(`The entered score (${value}) exceeds the maximum score (${maxScore}) for this question.`);
      return;
    }

    const updatedScores = {
      ...scores,
      [`${section.sectionName}-${question.questionNo}`]: value,
    };

    setScores(updatedScores);
    synchronizeState(marks, updatedScores);
  };
  const synchronizeState = (updatedMarks, updatedScores) => {
    setMarks(updatedMarks);
    setScores(updatedScores);

    saveToGlobalState(selectedStudent.id, page, updatedMarks, comments);
  };


  const saveToGlobalState = (studentId, page, marks, updatedComments) => {
    setGlobalState(prevState => ({
      ...prevState,
      [studentId]: {
        ...prevState[studentId],
        marks: { ...marks },
        comments: { ...updatedComments },
      },
    }));
  };


  const handleImageClick = (e) => {
    if (!selectedQuestion) {
      alert("Please select a question first before marking.");
      return;
    }

    if (!selectedLabel) {
      alert("Please select a Mark / Label first before marking.");
      return;
    }

    const rect = imageRef.current.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 100;
    const y = ((e.clientY - rect.top) / rect.height) * 100;

    const questionKey = `${selectedQuestion.sectionName}-${selectedQuestion.questionNo}`;
    let updatedMarks = { ...marks };
    let newScores = { ...scores };

    // Handle visual-only labels
    if (selectedLabel === "correct" || selectedLabel === "wrong") {
      const pageMarks = marks[page] || [];
      const newMarksForPage = [
        ...pageMarks,
        { questionKey, label: selectedLabel, x: x.toFixed(2), y: y.toFixed(2) },
      ];
      updatedMarks = { ...marks, [page]: newMarksForPage };
    } else {
      // Numerical label logic
      const newMarkValue = (
        parseFloat(scores[questionKey] || 0) + parseFloat(selectedLabel)
      ).toFixed(2);

      if (newMarkValue > selectedQuestion.marks) {
        alert(
          `The total score (${newMarkValue}) exceeds the maximum score (${selectedQuestion.marks}) for this question.`
        );
        return;
      }

      const pageMarks = marks[page] || [];
      const newMarksForPage = [
        ...pageMarks,
        { questionKey, label: selectedLabel, x: x.toFixed(2), y: y.toFixed(2) },
      ];

      updatedMarks = { ...marks, [page]: newMarksForPage };
      newScores = { ...scores, [questionKey]: newMarkValue };
    }

    synchronizeState(updatedMarks, newScores);
    setSelectedLabel(null);
    addHistoryState(updatedMarks, newScores);
  };

  const handleMarkRemove = (e, index, mark) => {
    e.stopPropagation();

    const pageMarks = [...(marks[page] || [])];
    const newPageMarks = pageMarks.filter((_, i) => i !== index);

    const updatedScore = parseFloat(scores[mark.questionKey] || 0) - parseFloat(mark.label);

    const updatedMarks = { ...marks, [page]: newPageMarks };
    const updatedScores = {
      ...scores,
      [mark.questionKey]: updatedScore > 0 ? updatedScore.toFixed(2) : "",
    };

    synchronizeState(updatedMarks, updatedScores);
    addHistoryState(updatedMarks, updatedScores);
  };

  const addHistoryState = (updatedMarks, updatedScores) => {
    const updatedHistory = history.slice(0, historyIndex + 1);
    updatedHistory.push({ marks: { ...updatedMarks }, scores: { ...updatedScores } });
    setHistory(updatedHistory);
    setHistoryIndex(updatedHistory.length - 1);
  };


  const updateGlobalStateToBackend = useCallback(async () => {
    try {
      const payload = {
        ...globalState,
        [selectedStudent.id]: {
          ...globalState[selectedStudent.id],
          overallComment,
        },
      };
      await UpdateScoresByDigitalEvaluator(id,selectedStudent.id, payload);
      console.log("Global state successfully sent to the backend.");
    } catch (error) {
      console.error("Failed to send global state to the backend:", error);
    }
  }, [globalState, overallComment,student]);


  useEffect(() => {
    if (globalState && Object.keys(globalState).length > 0) {
      updateGlobalStateToBackend();
    } else {
      console.warn("Global state is empty, skipping backend update.");
    }
  }, [globalState, updateGlobalStateToBackend]);

  const undo = () => {
    if (historyIndex > 0) {
      const prevState = history[historyIndex - 1];
      setMarks(prevState.marks);
      setScores(prevState.scores);
      setComments(prevState.comments || {}); // Restore comments
      saveToGlobalState(selectedStudent.id, page, prevState.marks, prevState.scores, prevState.comments || {});
      setHistoryIndex(historyIndex - 1);
    } else {
      alert("No more undo history.");
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {
      const nextState = history[historyIndex + 1];
      setMarks(nextState.marks);
      setScores(nextState.scores);
      setComments(nextState.comments || {}); // Restore comments
      saveToGlobalState(selectedStudent.id, page, nextState.marks, nextState.scores, nextState.comments || {});
      setHistoryIndex(historyIndex + 1);
    } else {
      alert("No more redo history.");
    }
  };


  return (
    <main className="flex bg-base-100 h-screen w-screen overflow-hidden m-0">
      {/* Left Bar */}
      <div className={`bg-white flex flex-col p-4 h-full overflow-auto rounded-md shadow-md lg:w-[20vw] ${lmenu
        ? "absolute max-lg:z-[1200] max-lg:w-[80vw] max-lg:h-full"
        : "max-lg:hidden"
        }`}>
        <div className="flex justify-between items-center  mb-4">
          <Link href="/">
            <Image src={Logo} height={50} alt="AutogradeX" />
          </Link>
          <IconButton
            size="large"
            edge="start"
            onClick={() => setLmenu(false)}

            sx={{ display: { lg: "none" } }}
            className="lg:hidden"
          >
            <CloseIcon />
          </IconButton>
        </div>
        {/* Tools Section */}
        <div className="mb-6">
          <Typography variant="subtitle1" className="mb-2">
            Tools
          </Typography>
          <div className="flex flex-wrap gap-2">

            <Tooltip title="Redo">
              <Button
                variant={"contained"}
                onClick={redo}
              >
                <RedoIcon />
              </Button></Tooltip>

            <Tooltip title="Undo">
              <Button
                variant={"contained"}
                onClick={undo}
              >
                <UndoIcon />
              </Button></Tooltip>
            <Tooltip title="Right">
              <Button

                key={"correct"}
                variant={selectedLabel === "correct" ? "contained" : "outlined"}
                onClick={() => setSelectedLabel("correct")}
                color="success"
              >
                <DoneIcon />
              </Button></Tooltip>
            <Tooltip title="Wrong">
              <Button
                key={"wrong"}
                variant={selectedLabel === "wrong" ? "contained" : "outlined"}
                onClick={() => setSelectedLabel("wrong")}
                color="error"
              >
                <ClearIcon />
              </Button></Tooltip>

          </div>
        </div>
        {/* Marks Section */}
        <div>
          <Typography variant="subtitle1" className="mb-4">
            Marks
          </Typography>
          <div className="flex flex-wrap gap-1">
            {marksLabels.map((label) => (
              <Button
                key={label}
                variant={selectedLabel === label ? "contained" : "outlined"}
                color="success"
                onClick={() => setSelectedLabel(label)}
                className={`${selectedLabel === label ? "bg-green-500 text-white" : ""
                  }`}
              >
                {label}
              </Button>
            ))}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex flex-col w-full h-full">
        {/* Navbar */}
        <AppBar
          position="sticky"
          sx={{ height: 80, display: "flex", justifyContent: "center" }}
          elevation={0}
          className="bg-white"
          color="transparent">
          <Toolbar>
            <IconButton
              size="large"
              edge="start"
              onClick={() => setLmenu(!lmenu)}
              sx={{ display: { lg: "none" } }}
            >
              <MenuIcon />
            </IconButton>
            <Typography variant="p" clasName="bg-white shadow m-2">Subject : <b>{assignments?.subject}</b> <br /> Exam : {assignments?.name}</Typography>

            <Box sx={{ flexGrow: 1 }} />
            <Box sx={{ display: "flex", alignItems: "center" }}>

              <FormControl variant="standard" sx={{ m: 2, minWidth: 200 }}>
                <InputLabel id="student-select-label">Student</InputLabel>
                <Select
                  labelId="student-select-label"
                  onChange={(e) => {
                    setStudent(e.target.value);
                    setPage(undefined);
                    resetStudentData();
                  }}
                  label="Student"
                >
                  {assignments?.students?.map((student) => (
                    <MenuItem key={student.id} value={student}>
                      {student.name}
                    </MenuItem>
                  ))}
                </Select>

              </FormControl>
              <Link href="/" className="h-full">
                <Tooltip title="Back to Dashboard">
                  <IconButton variant="outlined">
                    <ArrowBack color="error" />
                  </IconButton>
                </Tooltip>
              </Link>
              <IconButton
                size="large"
                edge="start"
                onClick={() => setRmenu(!rmenu)}
                sx={{ display: { lg: "none" } }}
              >
                <MenuIcon />
              </IconButton>
            </Box>
          </Toolbar>
        </AppBar>


        {/* Main White Box */}
        <Box className="h-full p-4 flex-grow m-0 bg-[#F5F5F5] overflow-y-auto rounded-md shadow-md">

          <Box className="bg-white p-0 w-full">
            {page ?
              <div
                style={{ position: "relative", width: "100%", cursor: "crosshair" }}
                onClick={handleImageClick}
              >
                <img
                  src={page}
                  alt="Answer Script"
                  ref={imageRef}
                  className="w-full"
                  style={{ display: "block" }}
                />
                {page && marks[page] ? (
                  marks[page].map((mark, index) => (
                    <div
                      key={index}
                      title={`Label: ${mark.label}`}
                      style={{
                        position: "absolute",
                        top: `${mark.y}%`,
                        left: `${mark.x}%`,
                        transform: "translate(-50%, -50%)",
                        color: "white",
                        backgroundColor: mark.label === "correct"
                          ? "rgba(0, 128, 0, 0.8)" // Green for correct
                          : mark.label === "wrong"
                            ? "rgba(255, 0, 0, 0.8)" // Red for wrong
                            : "rgba(0, 128, 0, 0.8)", // Default green for numeric marks
                        width: "40px",
                        height: "40px",
                        borderRadius: "50%",
                        cursor: "pointer",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                      }}
                      onMouseEnter={() => setHoveredMark(index)} // Set hovered mark index
                      onMouseLeave={() => setHoveredMark(null)} // Clear hovered mark index
                    >
                      {/* Display the appropriate content based on the label */}
                      {mark.label === "correct" ? (
                        <DoneIcon style={{ fontSize: "24px", color: "white" }} />
                      ) : mark.label === "wrong" ? (
                        <ClearIcon style={{ fontSize: "24px", color: "white" }} />
                      ) : (
                        mark.label // Numeric label
                      )}

                      {/* Display X symbol when hovered */}
                      {hoveredMark === index && (
                        <span
                          onClick={(e) => handleMarkRemove(e, index, mark)}
                          style={{
                            position: "absolute",
                            top: "-8px",
                            right: "-8px",
                            backgroundColor: "white",
                            color: "red",
                            borderRadius: "50%",
                            width: "18px",
                            height: "18px",
                            fontWeight: "bold",
                            cursor: "pointer",
                            fontSize: "12px",
                            display: "flex", // Ensures centering
                            alignItems: "center", // Vertically centers the content
                            justifyContent: "center", // Horizontally centers the content
                            boxShadow: "0 0 2px rgba(0, 0, 0, 0.2)", // Adds a subtle shadow
                          }}
                          title="Remove Mark"
                        >
                          ✖
                        </span>
                      )}
                    </div>
                  ))
                ) : (
                  ""
                )}

              </div> : <Typography className="p-2" variant="h5">Select Student and Paper</Typography>}

          </Box>
        </Box>
      </div>

      {/* Right Bar */}
      <div className={`bg-white flex flex-col p-4 h-full rounded-md overflow-x-hidden overflow-y-auto shadow-md lg:w-[35vw] ${rmenu
        ? "absolute right-0 max-lg:z-[1200] max-lg:w-[60vw] max-lg:h-full"
        : "max-lg:hidden"
        }`}
        style={{ maxHeight: "100vh" }}>
        {/* Header */}
        <div className="flex justify-between items-center mb-4">

          <IconButton
            size="large"
            edge="start"
            onClick={() => setRmenu(false)}
            sx={{ display: { lg: "none" } }}
            className="lg:hidden"
          >
            <CloseIcon />
          </IconButton>
        </div>

        {/* Scrollable Table Section */}
        <div className="flex-grow mb-4 overflow-y-scroll  p-2 custom-scrollbar overflow-hidden" style={{ maxHeight: "40vh" }}>
          <Typography
            variant="subtitle1"
            className="mb-2 text-green-600 font-bold uppercase"
          >
            Questions Table
          </Typography>
          <table className="table-auto w-full text-left text-xs">
            <thead className="bg-green-100 sticky top-0 z-10">
              <tr>
                <th className="p-1 border-b border-green-300">Section</th>
                <th className="p-1 border-b border-green-300">Question</th>
                <th className="p-1 border-b border-green-300">Scored</th>
                <th className="p-1 border-b border-green-300">Max Score</th>
              </tr>
            </thead>
            <tbody>
  {assignments?.assignmentStructure.map((section, sectionIndex) => (
    <>
      {/* Section Header */}
      <tr key={`section-${sectionIndex}`} className="bg-green-200">
        <td colSpan="4" className="p-1 font-semibold text-green-800">
          {section.sectionName}
        </td>
      </tr>
      {/* Section Questions */}
      {section.questions.map((question, questionIndex) => (
        <tr key={`question-${sectionIndex}-${questionIndex}`} className="hover:bg-green-50">
          <td className="p-1 text-center">{section.sectionName}</td>
          <td className="p-1">
            <Button
              color={
                selectedSection === section &&
                selectedStudent === student
                  ? "success"
                  : "inherit"
              }
              variant={
                selectedSection === section &&
                selectedStudent === student &&
                selectedQuestion.questionNo === question.questionNo
                  ? "contained"
                  : "outlined"
              }
              className={`rounded-full ${
                selectedSection === section && selectedStudent === student
                  ? "bg-green-500 text-white"
                  : "text-green-600"
              }`}
              onClick={() => {
                setSelectedSection(section);
                setSelectedStudent(student);
                setSelectedQuestion({ ...question, sectionName: section.sectionName });
              }}
            >
              {section.sectionName}.{question.questionNo}
            </Button>
          </td>
          {/* Scored Marks Input */}
          <td className="p-1 text-center">
            <input
              type="number"
              className="w-full border border-green-300 rounded p-1 text-center"
              value={scores[`${section.sectionName}-${question.questionNo}`] || 0} // Use 0 as default value
              onChange={(e) =>
                handleScoreChange(section, question, e.target.value)
              }
            />
          </td>
          <td className="p-1 text-center">{question.marks}</td>
        </tr>
      ))}
    </>
  ))}
</tbody>
<tfoot className="bg-green-100 sticky bottom-0">
  <tr>
    <td colSpan="2" className="p-1 font-semibold text-right">
      Total Marks:
    </td>
    <td className="p-1 text-center font-semibold">
      {/* Calculate total scored marks */}
      {Object.values(scores).reduce((sum, score) => sum + parseFloat(score || 0), 0)}
    </td>
    <td className="p-1 text-center font-semibold">
      {/* Calculate total maximum marks */}
      {assignments?.assignmentStructure.reduce((totalMax, section) =>
        totalMax + section.questions.reduce((sectionMax, question) => sectionMax + question.marks, 0),
        0
      )}
    </td>
  </tr>
</tfoot>
          </table>

        </div>

        {/* Question Comment Box */}
        {selectedSection && selectedQuestion ? <div className="mb-4">
          <Typography
            variant="subtitle1"
            className="mb-2 text-green-600 font-bold "
          >
            Comment For {selectedSection.sectionName} -Q {selectedQuestion.questionNo}
          </Typography>
          <textarea
            className="w-full p-2 border border-green-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-green-500"
            rows="2"
            placeholder={`Comment for ${selectedQuestion.sectionName} - Q${selectedQuestion.questionNo}`}
            value={comments[`${selectedQuestion.sectionName}-${selectedQuestion.questionNo}`] || ""}
            onChange={(e) => handleCommentChange(selectedQuestion, e.target.value)}
          />
        </div> : ""}


        {/* OverAll Comment Box */}
        <div className="mb-4">
          <Typography
            variant="subtitle1"
            className="mb-2 text-green-600 font-bold "
          >
            Suggestions / Recommendations for {student?.name}
          </Typography>
          <textarea
            className="w-full p-2 border border-green-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-green-500"
            rows="2"
            placeholder="Enter your overall performance comment here..."
            value={overallComment}
            onChange={(e) => handleOverallCommentChange(e.target.value)}
          />
        </div>

        {/* Scrollable Pagination Section */}
        <div className="" style={{ maxHeight: "40vh" }}>
          <Typography
            variant="subtitle1"
            className="mb-2 text-green-600 font-bold uppercase"
          >
            Pages
          </Typography>
          <div className="flex items-center m-2 p-2 gap-2 overflow-x-auto">
            {
              student?.answerScript?.map((paper, index) => (
                <Button
                  key={paper.id || index}
                  variant={page === paper ? "contained" : "outlined"}
                  className="mx-1 my-1"
                  value={paper}
                  onClick={() => {
                    setPage(undefined);
                    setPage(paper)
                  }}
                >
                  {index}
                </Button>
              ))
            }
          </div>
        </div>
      </div>


    </main>
  );
}
